---
title: 数据库必知必会-索引篇
date: 2022-02-16 23:20:03
updated:
mathjax: true
categories:
tags: 
---


1. Mysql 数据库有哪些索引以及他们各自的特点？InnoDB为什么选择用B+树作为索引，而不用B树？  

|  索引   | 特点 | 使用场景 |
|  ----  | ----  | ---- |
| hash索引  | 散列表实现，等值查询效率高，不能排序,不能进行范围查询 | 不需要范围查询，仅需等值查询时，可以考虑使用|
| BTree索引  | B+树实现，支持范围查询 |默认|
| RTree索引  | 仅支持地理位置类型，RTree空间树实现，相比Btree有更好的范围查询性能 |有按照地理位置检索需要的场景|
| FullText索引  | 分词加倒排索引实现 |有类似like的全文检索类型的查询|

2. 索引匹配原则：左前缀匹配原则
3. 聚簇索引、非聚簇索引是怎么回事？
   
|  索引   | 特点 | 使用场景 |
|  ----  | ----  | ---- |
| 聚簇索引  | 数据按照索引顺序存储，叶子节点存储真实的数据 | InnoDB索引|
| 非聚簇索引  | 叶子节点存储指向真正数据行的指针 |MyISAM|
4. 数据库回表是怎么回事？如何避免？
   在查询辅助索引时，如果要查询的字段已经全部在索引中了，那么就不需要额外再查询主索引了；反之，如果要查询的字段当前索引无法覆盖，那么Mysql需要额外查询主索引去获取要查询的字段，访问索引的次数多了一次，我们称刚才的过程为回表。我们通过增加全覆盖索引可以避免回表。
5. 出现慢查询时会用explain来定位解决
6. 索引为什么要用B+树来实现？
    首先，相比红黑树、AVL等二叉平衡树，B+树更加矮胖，这样子索引查找便能够更好的访问磁盘IO，从而有更好的查询性能；另外相比B树，B+树在叶子节点之间维护了一根链表，借助该链表，范围查找性能更加稳定。
7. InnoDB索引与MyISAM索引的区别

|  索引   | 特点 | 使用场景 |
|  ----  | ----  | ---- |
| InnoDB索引  | InnoDB的主索引的叶子节点就是数据本身，而辅助索引的叶子节点是主键ID| InnoDB索引|
| MyISAM索引  | InnoDB的主索引与辅助索引没有区别，叶子节点存储都是指向真实数据行的指针|MyISAM|

8. 两种存储引擎区别与各自使用场景
  
|  存储引擎   | 特点  | 使用场景|
|  ----  | ----  | ---- |
| MyISAM  | 不支持外键，表锁，插入数据时锁定整个表，查表的总行数不需要扫表，索引与数据分开 | 不需要支持事务，绝大多数请求为读操作，系统崩溃后数据丢失可接受|
| InnoDB  | 支持外键，行级锁，事务，查表的总行数时需要扫表，必须有唯一索引，索引与数据在一个文件中 |需要支持事务，读写相当，不可接受数据丢失|

![MysqlB+树索引展示](https://images.gitbook.cn/b480a130-a1b6-11ea-97df-0d0e3bd6b465)

第二、了解数据库的那几把锁是怎么回事

 1. 悲观锁 VS 乐观锁（其实是两种思想）
    首先悲观锁、乐观锁并不是两种锁，而是两种思想，两种用于实现并发控制的思想。其中，悲观锁指的是对数据被外界修改持悲观态度，认为数据大概率会被他人修改，所以在我准备修改数据时，我会对该数据加锁以避免其他人对该数据进行并发访问。而乐观锁指的是对外部修改数据持乐观态度，认为数据不会修改，所以我会直接对数据进行修改，在修改的以后再进行冲突的检查。如果修改失败了，我再决定如何去做。悲观锁适合写多读少的场景，而乐观锁适合读多写少的场景。悲观锁一般通过数据库锁来实现，而乐观锁一般是通过CAS来实现。
 2. 意向锁是什么？ 为什么需要意向锁？
   意向锁是实现多粒度锁的一种方式，是表锁，分为意向排他锁、意向共享锁，意向锁之间是兼容的；意向锁与表级别的共享锁、拍他锁是可能互斥的；意向锁与行级的互斥锁、共享锁是兼容的；实现意向锁的目的有两个：第一，让多粒度锁共存；第二，加快是否可以加锁的判定效率。

|   | 意向共享锁  | 意向互斥锁|
|  ----  | ----  | ---- |
| 意向共享锁  | 兼容 | 兼容|
|  意向互斥锁 | 兼容|兼容|

|   | 意向共享锁  | 意向互斥锁|
|  ----  | ----  | ---- |
| 表级共享锁  | 兼容 | 互斥|
|  表级互斥锁 | 互斥|互斥|

|   | 意向共享锁  | 意向互斥锁|
|  ----  | ----  | ---- |
| 行级共享锁  | 兼容 | 兼容|
|  行级互斥锁 | 兼容|兼容|
 3. 共享锁、拍他锁、意向共享锁、意向拍他锁
 4. 行锁 VS 表锁
 5. Record lock、gap lock、next-key lock
    record lock, 行锁， 锁直接加在索引记录上面，锁住的是key。
    gap lock, 间隙锁，用来解决幻读问题
    next-key lock， gap lock + reocrd lock
    关于next-key lock的两个原则、两个优化、一个bug:
    原则1: 加锁的基本单位是next-key lock, 前开后闭区间
    原则2: 查找过程中遇到的对象才会加锁
    优化1: 索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁
    优化2: 索引上的等值查询，向右遍历时且最后一个值不满足等值条件时，next-key lock退化为gap lock
    bug: 唯一索引的范围查找会访问到不满足条件的第一个值为止。

    https://blog.csdn.net/zwx900102/article/details/106544634?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control

![数据库锁](https://images.gitbook.cn/c347e4d0-a1b6-11ea-97df-0d0e3bd6b465)

第三、了解事务特性、各种隔离级别以及相应的问题

  事务的特性：

  A 原子性，要么执行要么不执行
  C 一致性，事务前后，数据总额一致 
  I 隔离型，所有操作全部执行完以前其它会话不能看到过程
  D 持久性，一旦事务提交，对数据的改变就是永久的

  可能出现的问题：

  脏读，事务B读到事务A还没有提交的数据
  不可重复读，一行被SELECT两次，返回的结果不一样
  幻读，两次读取返回的集合不一样

  四种隔离级别：

  读未提交，在该隔离级别，会出现脏读、不可重复读、幻读等问题。
  读已提交，该隔离级别解决了脏读的问题，依旧会出现不可重复读、幻读问题。
  可重复读，该隔离解决进一步解决了不可重复读的问题，会出现幻读问题。（但是对于InnoDB存储引擎，通过间隙锁解决了该问题，不会出现幻度现象）
  串行，该隔离级别把所有操作都串行化了，没有并发访问，解决了以上所有问题。

![数据库各隔离级别会出现的问题](https://images.gitbook.cn/d9fd08e0-a1b6-11ea-bf38-950ba54cfedc)

虽说希望你了解，但是友情提示一波：线上高并发应用，尽量不要用事务！

第四、了解InnoDB存储引擎的几个概念

Redo log: 是什么？ 通过它解决了什么问题？redo log是InnoDB存储引擎为了解决事务持久性而引入的WAL技术。借助redo log，InnoDB存储引擎将事务的commit提交简化为一次内存操作与一次磁盘写入操作。
如果磁盘页中的数据发生了丢失，也就是在崩溃恢复过程中，存储引擎会通过重做redo log中的操作来进行数据恢复。

binlog: 又是什么？他是干什么用的？ 了解主从同步原理。binlog是Mysql server层为了解决主从数据同步而引入的一套日志系统。binlog中记录的是一个数据行发生了什么操作。

LBCC，基于锁的并发控制，英文全称Lock Based Concurrency Control。这种方案比较简单粗暴，就是一个事务去读取一条数据的时候，就上锁，不允许其他事务来操作(当然这个锁的实现也比较重要，如果我们只锁定当前一条数据依然无法解决幻读问题)。

MVCC: 什么是MVCC、它的作用、他的大致实现；MVCC是InnoDB存储引擎为了实现事务的隔离级别而引入的一种乐观锁机制。

快照读、锁定读：了解这两种读取方式的发生时机以及如何实现的？
一致性读视图包括：视图数组（活跃的事务） + 高水位（已经创建过的事务ID + 1）
如果是可重复读，那么事务开启时创建一次访问视图，
如果是读已提交，那么事务每一个语句执行前都会重新计算出新的视图。

https://www.cnblogs.com/leeeeemz/p/12586815.html

Undo log: 是什么？ 通过它解决了什么问题？ 数据的多个版本，临时写在undo log中，并通过链表管理起来。

InnoDB的几个关键特性：insert buffer、double write、自适应hash索引、异步写等

Redo Log与binlog的两阶段提交
（1）prepare阶段，先写入rede log（状态为准备中）
（3）写入binlog（状态为已提交）--- TX_ID
（2)commit阶段，写入redo log（状态为已提交）

数据库事务
ACID
脏读
幻读
不可重复度

并发控制：乐观并发控制、悲观并发控制

悲观锁(Pessimistic Lock)
每次操作之前都枷锁

乐观锁