---
title: 动态规划分类索引
date: 2021-01-11 22:54:03
updated:
copyright: true
description: 
mathjax: true
categories:
tags: 
---

动态规划

七、动态规划优化策略
费用提前/延后计算：没有关于某个维度的限制条件，这个维度纯粹用来计算费用，考虑是否可以提前计算

多阶段决策最优化问题

重复子问题、无后效性、最优子结构

最短编辑距离、最长公共子串、最大子数组、硬币找零问题、杨辉三角、01背包问题

常见的动态规划问题有哪些：

|  LIS问题  | |
|  ----  | ----  |
| 问题描述   | 最长上升子序列。给定一个长度为N的数列A，求数值单调递增的子序列的长度最长是多少。A的任意子序列B可表示为$B={A_{k_1},A_{k_2},A_{k_3},\ldots,A_{k_p}}$，其中$k_1 < k_2 <\ldots<k_p$|
| 状态表示  |F[i]表示以A[i]为结尾的最长上升子序列的长度|
| 阶段划分 | 子序列的结尾位置（数列A中的位置，从前到后） |
| 转移方程  |$F[i]=\underset{0 \le j \lt i,A[j] \lt A[i]}{\mathrm{max}}\{F[i] + 1\}$|
| 边界  | F[0]= 0|
| 目标  | $\underset{1 \le i \le N}{\mathrm{max}}{F[i]}$|

|  LCS问题  | |
|  ----  | ----  |
| 问题描述   | 最长公共子序列。给定两个长度分别为N和M的字符串A和B，求即是A的子序列又是B的子序列的字符串长度最长是多少。|
| 状态表示  |F[i,j]表示前缀子串A[1-i]与B[1-j]的最长公共子序列的长度|
| 阶段划分 | 已经处理的前缀长两个字符串中的位置，即一个二维坐标） |
| 转移方程  |$F[i,j]=\begin{cases}F[i,j-1] \\ F[i-1,j] \\ F[i-1,j-1] + 1 & \text{if } A[i] = B[j] \end{cases}$|
| 边界  | F[i,0]=F[0,j]=0|
| 目标  | $F[N,M]$|

|  数字三角形  | |
|  ----  | ----  |
| 问题描述   | 给定一个共有N行的三角矩阵A，其中第i行有i列。从左上角出发，每次可以向下方或者右下方走一步，最终到达底部。求把经过的所有位置上的数加起来，和最大是多少。|
| 状态表示  |F[i,j]表示从左上角走到第i行，第j列，和最大是多少|
| 阶段划分 | 路径的结尾位置（矩阵中的行列位置，即一个二维坐标) |
| 转移方程  |$F[i,j]=A[i,j]+\begin{cases}F[i-1,j] \\ F[i-1,j-1] & \text{if } j \gt 1 \end{cases}$|
| 边界  | F[1,1]=A[1,1]|
| 目标  | $\underset{1 \le j \le N}{\mathrm{max}}{F[N,j]}$|

|  01背包问题  |背包问题系列 |
|  ----  | ----  |
| 问题描述   | 给定N个物品，其中第i个物品的体积为$V_i$，价值为$W_i$。有一个容积为M的背包，要求选择一些物品放入背包，使得物品总体积不超过M的前提下，物品总价值和最大。|
| 状态表示  |F[i,j]表示从前i个物品中选出了总体积为j的物品放入背包，物品的最大价值|
| 阶段划分 | 主阶段：已经处理的物品数，以背包中放入到的物品总体积为附加维度|
| 转移方程  |$F[i,j]=\begin{cases}F[i-1,j] & \text { 不选第i个物品} \\ F[i-1,j-V_i] + W_i & \text{if } j \ge V_i  \text{ 选第i个物品} \end{cases}$|
| 边界  | F[0,0]=0，其余为负无穷|
| 目标  | $\underset{0 \le j \le M}{\mathrm{max}}{F[N,j]}$|
| 优化  | 仅依赖前一项，可以通过滚动数组或者倒序循环做空间优化|

|  数字组合（01背包模型）  |背包问题系列 |
|  ----  | ----  |
| 问题描述   | 给定N个正整数$A_1,A_2,A_3,\dots,A_N$，从中选出若干个数，使他们的和是M，求有多少种选择方案。|
| 状态表示  |F[i,j]表示使用前i个物品拼凑出总体积为j的物品的方案数|
| 阶段划分 | 主阶段：已经处理的物品数，拼凑出的总体积是附加维度|
| 转移方程  |$F[i,j]=F[i-1,j] + F[i-1,j-A_i]$ 第一项是不选择第i个物品，第二项是选择第i个物品|
| 边界  | F[0,0]=1，其余为0|
| 目标  | F[N,M]|

|  完全背包问题  |背包问题系列 |
|  ----  | ----  |
| 问题描述   | 给定N个物品，其中第i个物品的体积为$V_i$，价值为$W_i$，并且有无限个。有一个容积为M的背包，要求选择一些物品放入背包，使得物品总体积不超过M的前提下，物品总价值和最大。|
| 状态表示  |F[i,j]表示从前i个物品中选出了总体积为j的物品放入背包，物品的最大价值|
| 阶段划分 | 主阶段：已经处理的物品数，以背包中放入到的物品总体积为附加维度|
| 转移方程  |$F[i,j]=\begin{cases}F[i-1,j] & \text {不选第i个物品} \\ F[i,j-V_i] + W_i & \text{if } j \ge V_i  & \text{ 选第i个物品} \end{cases}$|
| 边界  | F[0,0]=0，其余为负无穷|
| 目标  | $\underset{0 \le j \le M}{\mathrm{max}}{F[N,j]}$|
| 优化  | 正循环做空间优化|

|  多重背包问题  |背包问题系列 |
|  ----  | ----  |
| 问题描述   | 给定N个物品，其中第i种物品的体积为$V_i$，价值为$W_i$，并且有$C_i$个。有一个容积为M的背包，要求选择一些物品放入背包，使得物品总体积不超过M的前提下，物品总价值和最大。|
| 问题转换  |将第i种物品看作独立的$C_i$个物品，从而转换为共有$\sum\limits_{i=1}^{N}C_i$个物品的0/1背包问题|
| 问题转换  |将数量为$C_i$的第i个物品拆成p+2个物品，他们的体积分别为：$2^0V_i,2^1V_i,\dots,2^pV_i,R_iV_i$，其中$R_i=C_i-2^0-2^1-\dots-2^p$|
| 问题优化  |可借助单调队列优化|

|  分组背包问题  |背包问题系列 |
|  ----  | ----  |
| 问题描述   | 给定N个物品，其中第i组有$C_i$个物品。第i组的第j个物品的体积为$V_{ij}$，价值为$W_{ij}$。有一个容积为M的背包，要求选择一些物品放入背包，使得每组最多选择一个物品并且总体积不超过M的前提下，物品总价值和最大。|
| 状态表示  |F[i,j]表示从前i组选出了总体积为j的物品放入背包，物品的最大价值|
| 转移方程  |$F[i,j]=\begin{cases}F[i-1,j] & \text { 不选第i组的物品} \\ \underset{1 \le k \le C_i}{\mathrm{max}}{F[i - 1,j - V_{ik}] + W_{ik}} &\text{ 选第i个物品} \end{cases}$|
| 阶段划分 | 主阶段：i物品组数是阶段，i与j共同组成状态，k是决策|
| 边界  | F[0,0]=0，其余为负无穷|
| 目标  | $\underset{0 \le j \le M}{\mathrm{max}}{F[N,j]}$|
| 优化  | 正循环做空间优化|

|  最小硬币数  |换硬币系列 |
|  ----  | ----  |
| 问题描述   | 给定N种硬币，其中第i种面额为$C_i$，计算凑成总金额M所需的最少的硬币个数。每种硬币的数量是无限的。|
| 状态表示  |F[i]表示凑出金额i用的最小硬币数|
| 转移方程  |$F[i]=\underset{1 \le j \le N}{\mathrm{min}}{F[i - C_j] + 1}$|
| 边界  | F[0]=0，其余为正无穷|
| 目标  | F[M]|

|  求硬币拼凑的总方案数  |换硬币系列 |
|  ----  | ----  |
| 问题描述   | 给定N种硬币，其中第i种面额为$C_i$，计算凑成总金额M的所有方案数|
| 状态表示  |F[i,m]表示利用前i种硬币凑出金额m的方案数|
| 转移方程  |$F[i]=\sum\limits_{j=1}^{N} {F[i - C_j]}$|
| 边界  | F[0]=1，其余为0|
| 目标  | F[M]|

|  求硬币拼凑的总方案数  |换硬币系列 |
|  ----  | ----  |
| 问题描述   | 给定N种硬币，其中第i种面额为$C_i$，计算凑成总金额M的所有方案数，顺序不同的序列视为同一种方案|
| 底层模型  |完全背包模型|
| 状态表示  |F[i,m]表示利用前i种硬币凑出金额m的方案数，求组合的技巧在于**定序**|
| 优化前转移方程  |$F[i,j]=F[i-1,j] + F[i - 1,j-V_i] + F[i - 1,j-2V_i] + \dots + F[i - 1,j- kV_i]$|
| 优化后转移方程  |$F[i,j]=F[i-1,j] + F[i,j-V_i] $|
| 边界  | F[i][0]=1，F[0][k]=0, 其余为0|
| 目标  | F[N,M]|

|  一维最大子数组和 |最大子数组和系列 |
|  ----  | ----  |
| 问题描述   | 给定一个整数数组 nums 计作$A_i$，找到一个具有最大和的子数组（子数组最少包含一个元素），返回其最大和|
| 状态表示  |F[i]表示利用以$A_i$结尾的子数组的最大和|
| 转移方程 |$F[i]=\begin{cases}F[i-1]+A[i] & \text{if } F[i-1] \gt 0 \\ A[i] & \text{if } F[i-1] \le 0 \end{cases}$|
| 边界  | F[0]=0|
| 目标  | F[N]|
| 空间压缩 | 由于仅与前一项有关，所以可以用一个变量来代替|

|  一维最大子数组和 |扔鸡蛋系列 |
|  ----  | ----  |
| 问题描述   | 给定一个整数数组 nums 计作$A_i$，找到一个具有最大和的子数组（子数组最少包含一个元素），返回其最大和|
| 状态表示  |F[i]表示利用以$A_i$结尾的子数组的最大和|
| 转移方程 |$F[i]=\begin{cases}F[i-1]+A[i] & \text{if } F[i-1] \gt 0 \\ A[i] & \text{if } F[i-1] \le 0 \end{cases}$|
| 边界  | F[0]=0|
| 目标  | F[N]|
| 空间压缩 | 由于仅与前一项有关，所以可以用一个变量来代替|

打家劫舍问题
股票买卖问题
扔鸡蛋问题
字符串编辑距离问题
...

## 动态规划相关的经典题目

|  题目分类 | 题目名称 |考察点   |其他说明|
|  ----  | ---- |----  |----  |
| | [棋盘上获取最大价值的礼物](../getMaxValue.html)  ||
| | [获取不同的翻译方法次数](../getTranslationCount.html)  ||
| | [股票买卖系列](./stock_common.html)  ||
| | [子数组最大和](../pt_offer/sub_array_sum_max.html)  |子数组最大和问题|


请实现一个函数用来匹配包括'.'和'*'的正则表达式。

模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。

在本题中，匹配是指字符串的所有字符匹配整个模式。

例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配。

样例
输入：

s="aa"
p="a*"

输出:true

动态规则
f(i,j)表示字符串a从i到结尾是否匹配字符串b从j到结尾

给你一根长度为 n 绳子，请把绳子剪成 m 段（m、n 都是整数，2≤n≤58 并且 m≥2）。

每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]k[1] … k[m] 可能的最大乘积是多少？

例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。

样例
输入：8

输出：18

```cpp
class Solution {
public:
    vector<int> dp;
    
    int dfs(int n) {
        if (dp[n] > 0) {
            return dp[n];
        }
        
        if (n <= 3) {
            dp[n] = n - 1;
            return n - 1; 
        }
        if (n == 4) {
            dp[n] = 4;
            return dp[n];
        }
         if (n == 5) {
            dp[n] = 6;
            return dp[n];
        }
        int max_score = 0;
        for (int i = 2; i <= n - 2; ++i) {
            //分为两种情况：第一刀减在i处；剩下的那一部分可以有两种选择：不剪，或者继续剪
            max_score = max(max_score, max(i * (n - i), i * dfs(n - i)));
        }
        dp[n] = max_score;
        return dp[n];
    }

    int maxProductAfterCutting(int length) {
        dp = vector<int>(length + 5, 0);
        return dfs(length);
    }
};
```