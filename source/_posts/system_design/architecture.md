---
title: 系统架构
date: 2021-01-19 23:23:03
updated:
mathjax: true
categories:
- [系统设计]
tags: 
---

## 高并发系统的三个目标与挑战

高并发是一个系统的**挑战**

如何衡量一个系统的并发有多高呢？ 同时在线人数

高性能、高可用、可扩展是一个牛B系统**目标**

如何衡量一个吞吐量有多大呢？ QPS 吞吐量 = 并发进程数 / 响应时间
如何衡量一个系统的性能有多高呢？    接口响应时间，分位耗时
如何衡量一个系统的可用性有多高呢？  
平均故障间隔，平均故障恢复时间
![不同可用性标准下允许的故障时间](http://cdn.b5mang.com/202132011926.png)
如何衡量一个系统的可扩展能力？

### 高性能

提高吞吐量：
增加并发进程数
注意：无限增加，不会无限提升性能
![性能拐点模型](http://cdn.b5mang.com/202132011337.png)

减少响应时间

IO密集型：优化数据库索引、加缓存
CPU密集型：优化算法时间复杂度、减少不必要运算等

### 高可用

难度有多大：
三个9: 非核心业务可以容忍
四个9: 核心业务
运维值班体系、业务变更流程、故障处理流程、更加完善的系统故障排查工具
五个9: 必须让机器来自动处理恢复！

两个方面：
（1）系统设计-尽量思考故障发生后应该怎么办

考虑点：如何自动的发现故障、如何自动化的应对故障
具体方法：failover(故障转移)、超时控制、服务降级、熔断限流

failover:

- 完全对等
- 非完全对等（例如存在主备节点，心跳，选择paxos, raft等）

超时控制

全局超时控制

服务降级（区分核心流程与非核心流程）

限流

熔断

（2）系统运维-尽量避免故障发生

灰度发布（确保服务可回滚）

故障演练

### 可扩展

数据库、缓存、依赖的第三方、复杂均衡、交换机带宽都是系统扩展时需要考虑的点

数据库：按照业务拆分、分库分表
业务层：按照业务拆分、按照重要性拆分（核心、非核心）、按照请求来源（客户端、web、内网等）

分层的原因：本质上是为了让系统有更好的可扩展能力。

![架构分层](http://cdn.b5mang.com/2021320104242.png)

manager层：
（1）抽象service层可能提供的一些原子能力
（2）封装对第三方接口的调用

我觉得作为一个程序员，你首先**需要从高维度出发，从整体上思考问题**。
在我看来，秒杀（其实不只是秒杀，所有的高难度系统）其实主要解决两个问题，一个是**并发读**，一个是**并发写**。
并发读的核心优化理念是尽量减少用户到服务端来“读”数据，或者让他们读更少的数据；
并发写的处理原则也一样，它要求我们在数据库层面独立出来一个库，做特殊的处理。

另外，我们还要针对秒杀系统做一些保护，针对意料之外的情况设计兜底方案，以防止最坏的情况发生。

而从一个架构师的角度来看，要想打造并维护一个超大流量并发读写、高性能、高可用的系统，在整个用户请求路径上从浏览器到服务端我们要遵循几个原则，就是要保证用户请求的数据尽量少、请求数尽量少、路径尽量短、依赖尽量少，并且不要有单点。

核心需求点：

稳：高可用，负责兜底的PlanB

准：高一致，库存问题

快：高性能

两个大的方向：提升单次效率、减少不必要的请求

（1）动静分离方案
（2）热点的发现与隔离
（3）请求的削峰与分层过滤（异步化）
（4）服务端的极致优化（缓存）

Scale-out横向扩展
    分库分表、一主多从、数据分片都是该思想的具体操作方法。

如何在满足一个良好架构的分布式系统基础上，针对秒杀这种业务做到极致的性能改进

架构通用原则：“4 要 1 不要”

(1) 数据要尽量少

- 用户请求的数据能少就少
- 系统依赖的数据能少就少

(2) 请求数要尽量少

例如，静态文件合并

（3）路径要尽量短

将强依赖的服务进行单机部署

（4）依赖要尽量少

系统服务分级，高等级服务尽量少依赖低等级服务

（5）不要有单点

服务无状态，可扩展；存储层做副本备份

池化技术
核心思想：用空间换时间，期望使用预先创建好的对象来减少频繁创建对象的性能开销，同时还统一管理了对象，降低了对象的使用成本。
例子：
（1）数据库连接池-最小数量、最大数量、如果超过最大则等待
（2）线程池-最小数量、最大数量、有界队列（监控队列中元素的个数）
线程池大小：区分IO密集、CPU密集
（3）内存池

![JDK线程池提交任务示意图](http://cdn.b5mang.com/2021320121239.png)

池子的初始化

单体到微服务
（1）系统扩展性不足（例如，因为DB连接问题导致无法持续扩容）
（2）迭代效率低
（3）系统编译、部署成本高

微服务拆分的大原则

（1）单一服务内的高内聚、低耦合，单一职责
（2）拆分粒度：先粗拆，后细拆（伴随业务复杂度的变多，或者对业务的理解程度加深）
（3）拆分过程中，要避免影响业务的日常功能迭代--按照依赖顺序，挨个拆分
（4）确保服务接口定义有可扩展性

服务拆分带来的问题：
（1）接口调用耗时增加
（2）如何知道调用哪个服务？服务注册中心
（3）服务治理体系：熔断、限流、降级、超时控制等
（4）问题排查困难（分布式链路追踪）

你的团队成员结构是什么样的，你的架构就会长成啥样。
团队按照业务边界来拆分；确保团队不要太大
因为微服务就是为了减少研发成本，而包括沟通成本。

从单体到微服务，也许可以有一个过度：工程的拆分

#### 多机房部署

**同城多机房**：延迟1～3ms

主要看接口的实现（如果有几十次的跨机房交互，这种是不可接受的）
实现相对比较简单

单机房写入；每一个机房近读取本机房的缓存与数据
如果数据发生变更，需要做两边机房缓存的清理，一般通过canal订阅数据库变更

![同城多活示意图](http://cdn.b5mang.com/202132021118.png)

**国内异地多机房**:延迟50ms以内

尽量减少跨机房的调用；而应该避免跨机房的数据库与缓存操作

多机房写入，按照用户或者其他业务维度来进行流量分割，使得一部分流量总是请求A机房，而另外的总是请求B机房。

数据同步方式有两种：
（1）基于存储系统主从复制：同步redis、Mysql等
（2）基于消息队列：同步缓存、HBase的数据

![异步多活示意图]](http://cdn.b5mang.com/20213202149.png)

跨国多机房：延迟在100～200ms

避免跨机房的调用，而只能做异步同步



项目经历的思考
技术方案设计思路，排查线上问题的能力，以及对于项目架构演进方向的把握。

服务指标：qps, 缓存命中率
引导到你的强项？

技术难点？
诡异的地方，难查的地方？排查思路

排查rpc框架bug? 有那些疑难咋整？

cpu 某些cpu 100%？

strace 跟踪系统调用 top netstat