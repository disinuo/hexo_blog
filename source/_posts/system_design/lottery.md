---
title: 常见系统设计题系列-抽奖系统
date: 2021-01-18 18:48:03
updated:
mathjax: true
categories:
- [系统设计]
tags: 
---

## 不得不说的随机

拿音乐播放器的随机播放举一个例子，一般音乐播放器的随机播放分两种：
（1）播放当前歌曲时才随机生成下一首，即完全随机（称为Random算法）
（2）将当前的list打乱顺序，然后依次播放，也就是大家所说的伪随机（称为Shuffle算法）

对我们的Shuffle算法进行下抽象：

> 一个从1到n的序列，随机打乱，保证每个数出现在任意一个位置的概率相同。

<!-- more -->

```cpp
// 得到一个在闭区间 [min, max] 内的随机整数
int randInt(int min, int max);

void shuffle(int[] arr) {
    int n = arr.length();
    for (int i = 0 ; i < n; i++) {
        // 从 i 到最后随机选一个元素
        int rand = randInt(i, n - 1);
        swap(arr[i], arr[rand]);
    }
}
```

### 按照权重生成随机数

方法1: 如果随机选的话，在一个list中出现的次数多被选中的概率就会大。所以可以按照权重组合一个list，在这个list中A有50个，B有10个，C有100个，等等。有了list之后，从中随机选一个。这样选取的时间负责度是O(1)。但是如果数字很多，权重又很大的话，那么空间复杂度会很高。

方法2: 对每个元素的权重进行加和记为sum，在1到sum之间随机选一个数。之后遍历整个集合，统计遍历到的项的权重之和，如果大于sum，则选择这个数。该方法需要遍历集合，时间复杂度为O(n)

方案3: 上面方法最坏的情况是遍历完所有的元素，但是如果权重大的元素能够先被遍历的话可以减少遍历次数。基于此，可以先对元素按照权重排序。但是这样排序的话也会比较花时间。可以计算一个前项和序列，记录到每一项时的权重是多少。然后随机生成一个数，可以用二分查找找这个数对应的索引，也就可以找到对应的元素。

### 红包算法

有以下几个要点：
（1）预留足够的金额以确保每一个红包至少有钱（预留金额：0.01 * N)
（2）对剩余金额进行分配，使分配结果符合某种需要的分布：截尾正态分布、纯随机分布等

红包算法

首先，如果红包只有一个，本轮直接使用全部金额，确保红包发完。

然后，计算出本轮红包最少要领取多少，才能保证红包领完，即本轮下水位；轮最多领取多少，才能保证每个人都领到，即本轮上水位。主要方式如下：

计算本轮红包金额下水位：假设本轮领到最小值1分，那接下来每次都领到200元红包能领完，那下水位为1分；如果不能领完，那按接下来每次都领200元，剩下的本轮应全部领走，是本轮的下水位。

计算本轮红包上水位：假设本轮领200元，剩下的钱还足够接下来每轮领1分钱，那本轮上水位为200元；如果已经不够领，那按接下来每轮领1分，计算本轮的上水位。

为了使红包金额不要太悬殊，使用红包均值调整上水位。如果上水位金额大于两倍红包均值，那么使用两倍红包均值作为上水位。换句话说，每一轮抢到的红包金额，最高为两倍剩下红包的均值。

最后，获取随机数并用上水位取余，如果结果比下水位还小，则直接使用下水位，否则使用随机金额为本轮拆到金额。

2.1 二倍均值法

剩余红包金额为M，剩余人数为N，那么有如下公式：

每次抢到的金额 = 随机区间?（0， M / N X 2）

### 蓄水池算法

假设我这边有K个奖品，但是我不知道将来会有多少人来参与抽奖。我应该怎么处理呢？

### 微信红包架构

方案一，使用内存操作替代实时的 DB 事务操作。
    并发性能好，但是有可能丢失数据
方案二，使用乐观锁替代悲观锁。
    并发请求抢锁问题解决，但是用户体验不好

正确姿势：

1. 系统垂直 SET 化，分而治之。
   1. 按照红包ID来hash分流
2. 逻辑 Server 层将请求排队，解决 DB 并发问题。
   1. 首先，将同一个红包 ID 的所有请求 stick 到同一台 Server。
   2. 其次，设计单机请求排队方案。
   3. 最后，增加 memcached 控制并发。
3. 双维度库表设计，保障系统性能稳定
   1. 按照db_{红包IDhash}.table_{红包日期1～31}




